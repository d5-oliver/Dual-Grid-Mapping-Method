% Note: This file is intended to be executed from generateResults.m.
%
% This code is used to generate a latex table (requiring the tabularx
% package) containing approximations used in numerically determining order
% of accuracy as in tables 3 and 4. This file depends on the data stored in
% case_1_x_nodes.mat and case_1_y_steps.mat where x and y are specified in
% the NVals and KVals arrays respectively. If these files are not present,
% they can be generated by setting generateNew = true in the file
% generateResults.m. WARNING: generating new data is an intensive
% (computationally), time consuming process. Ensure adequate RAM (at least
% 32GB).

par.xL = 30;
par.tK = 18;
par.sigma = 1e+10;
par.omega = 1;

testCase = 1;
xL = par.xL;
tK = par.tK;
NVals = [121, 241, 481, 961, 1921, 3841]; % Number of spatial nodes
NMax = (NVals(end) - 1) * 2^3 + 1;
KVal = par.tK/(par.xL / (NVals(end) - 1))^2; % Number of time steps
KMax = KVal * 2^2;

run([topFolder,'\','testCases.m'])

if generateNew
    par.K = KVal;
    tSteps = 1:KMax/KVal:KMax+1;
    par.M = 11;
    par.xC = linspace(0,par.xL,par.M);
    for N = NVals
        par.N = N;
        par.xF = linspace(0,par.xL,par.N);
        PFactor = (par.N-1)/(par.M-1);

        c_FVM = FVM_Sparse(par);

        [C_DM,c_DM] = DM_Sparse(par);

        xStepsFine = 1:(NMax-1)/(N-1):NMax;
        xStepsCoarse = 1:PFactor*(NMax-1)/(N-1):NMax;

        par.N = NMax;
        par.xF = linspace(0,xL,par.N);
        par.K = KMax;
        madVals = FVM_Sparse_Large(par,xStepsFine,xStepsCoarse,tSteps,c_FVM,C_DM,c_DM,KVal);

        madFVM = max(madVals(:,1));
        madCDM = max(madVals(:,2));
        madFDM = max(madVals(:,3));
        save([bottomFolder,'\','case_1_',num2str(N),'_nodes_absDiff.mat'],'madVals','madFVM','madCDM','madFDM')

        par.K = KVal;
    end
end

% The max. abs. errors for each method are stored in the arrays hVals (for
% successively smaller node spacing) and tauVals (for successively smaller
% time step size). Methods are stored in order column-wise, starting with
% column:
% 1: Coarse-scale dual-grid interpolation mapping
% 2: Fine-scale dual-grid interpolation mapping
% 3: Coarse-scale dual-grid discretisation mapping
% 4: Fine-scale dual-grid discretisation mapping
hVals = cell(length(NVals),3);

% The max. abs. error ratios are stored in the same manner in the arrays
% hRatios (for successively smaller node spacing) and tauVals (for
% successively smaller time step size).
hRatios = cell(length(NVals),3);

tmp = 1;

for N = NVals

    load([bottomFolder,'\','case_1_',num2str(N),'_nodes_absDiff.mat'])

    hVals{tmp,1} = madFVM;
    hVals{tmp,2} = madCDM;
    hVals{tmp,3} = madFDM;

    if tmp > 1
        hRatios{tmp,1} = hVals{tmp-1,1} / hVals{tmp,1};
        hRatios{tmp,2} = hVals{tmp-1,2} / hVals{tmp,2};
        hRatios{tmp,3} = hVals{tmp-1,3} / hVals{tmp,3};
    end

    tmp = tmp + 1;

end


% Convert node spacing data to text
U = size(hVals,1);
V = size(hVals,2);
for ii = 1:U
    for jj = 1:V
        tmp = sprintf('%.2d',hVals{ii,jj});
        tmp = ['${',tmp(1:4),' \\times 10^{-',num2str(str2double(tmp(end-1:end))),'}}$'];
        hVals{ii,jj} = tmp;

        if ii == 1
            hRatios{ii,jj} = '--';
        else
            tmp = sprintf('%.3f',hRatios{ii,jj});
            hRatios{ii,jj} = ['$',tmp(1:4),'$'];
        end
    end
end


% Create algorithm type header
types = cell(1,2*V+1);

types{2} = '\\multicolumn{2}{l}{Fine-grid solution}';
types{3} = '';

types{4} = '\\multicolumn{2}{l}{DM (coarse-grid)}';
types{5} = '';

types{6} = '\\multicolumn{2}{l}{DM (fine-grid)}';
types{7} = '';


% Create node spacing data table
hTable = cell(U,2*V);
col = cell(U,1);
header = cell(1,2*V+1);
header{1} = '$h$';

for ii = 1:U
    col{ii} = ['$2^{-',num2str(ii+1),'}$'];
end

for jj = 1:2:2*V
    hTable(:,jj) = hVals(:,(jj-1)/2+1);
    header{jj+1} = 'Error';
end

for jj = 2:2:2*V
    hTable(:,jj) = hRatios(:,jj/2);
    header{jj+1} = 'Ratio';
end

hTable = [types;header;col,hTable];

hU = size(hTable,1);
hV = size(hTable,2);

latexTable = fopen([midFolder,'\','hTable.tex'],'w');

fprintf(latexTable,['\\begin{tabularx}{\\linewidth}{',repmat('X',1,hV),'}\n\\toprule\n & ']);
for jj = 2:2:hV
    if jj < hV-1
        fprintf(latexTable,[hTable{1,jj},' & ']);
    else
        fprintf(latexTable,[hTable{1,jj},' ']);
    end
end
fprintf(latexTable,'\\\\\n\\cmidrule(lr){2-3} \\cmidrule(lr){4-5} \\cmidrule(lr){6-7}\n');

for ii = 2:hU
    for jj = 1:hV
        if jj < hV
            fprintf(latexTable,[hTable{ii,jj},' & ']);
        else
            fprintf(latexTable,[hTable{ii,jj},' ']);
        end
    end
    if ii == 2
        fprintf(latexTable,'\\\\\n\\midrule\n');
    else
        fprintf(latexTable,'\\\\\n');
    end
end
fprintf(latexTable,'\\bottomrule\n\\end{tabularx}');

fclose(latexTable);
